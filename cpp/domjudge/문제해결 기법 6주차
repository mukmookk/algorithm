문제해결 기법 6주차

학생 풀이 A
set을 활용, count를 통해서 양쪽으로 카운트 하면서, 다른 값이 있다면 체크

학생 풀이 B(1) - skip

학생 풀이 B(2)
in-degree가 0이 아닌 노드에서 시작, Greedy choice property

플로이드 워셜의 경우 O(n^3) 시간 복잡도에서 손해

in-degree가 0 인 경우만을 순서 상관없이, 이를 큐에 넣어서 하나씩 뽑으며 다익스트라

Solution 

A.
모두 -1로 초기화한 check[26]
source에서 만나면 해당 문자는 0으로 초기화
이후 target에서 만나면 count++

만약 0인 경우가 있다면, NO

B.
일반적으로 노드간 최대 거리는 np-hard

DAG으로 그래프를 표현

topological sort (in-degree = 0)

다익스트라 -> source vertex가 1개

=> topological sort를 활용하여 vertex 연도 순으로 순서대로 계산될 수 있도록 (나가는 경로 기준)

연도 기준 오름차순 정렬, 쵀대 이동 시간에 대해서 각 지역마다 Time이 얼마나 걸리는지 배열로 생성

연도 기준으로 2011 -> 2012 -> 2012 -> ... 순으로 계산이 진행됌

만약 기존에 값이 있는 경우 큰 값으로 갱신

다음 노드로 나가면서 만약 다음 노드의 기존 longest time이 새로운 longest path 보다 작다면
새로운 longest path로 longest path를 갱신

최종적으로, 배열의 최대값을 출력

map을 사용해서 연도와 지역명 저장 -> map<string, int>
연도 별 정렬을 위한 vector<pair<int, string>>
인접 그래프를 통해, 특정 vertex에서 이동 가능한 지역과 시간을 저장, vector<pair<int,int>> edges[1..n]
마지막으로 각 vertex의 path 길이 table -> int dp[1..N]

--------
소스코


