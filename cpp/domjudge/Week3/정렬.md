각 문제마다 고유한 complexity가 존재

정렬의 경우에는 O(nlog(n)) 에 해당한다.
이보다 더 빠르게 정렬할 수 없게 된다. -> 이와 동일한 시간 복잡도를 가진 알고리즘의 경우 Optimal 알고리즘이라고 한다.

힙소트, 머지소트 (최악의 경우에도 optimal)
퀵소트는 최악의 경우 n^2

근데 이때 제한된 정렬문제의 경우, 선형 시간에 가능해진다.
-> Redix sort (기수 정렬)
-> Counting sort (계수 정렬)

1. counting array 초기화
2. 개수 카운팅 (rank)
3. 앞에서부터 누적합 구함
4. 마지막 인덱스에는 전체 원소의 개수가 된다.

5. 최종적으로 배열 B에 정렬된 값을 계산한다.
   1. 원본 Arr 뒤에서부터 각 값에 대해서 countingArr의 각 값의 누적합을 확인하고, 정렬이 된다면 누적합으로 도출된 index에 해당 값이 들어가야 함을 알 수 있다.
   2. 이후 countArr에 해당 값이 하나 줄었음을 -1함으로써 명시해준다.
   3. 그 다음에는 원본의 하나씩 앞으로 가주면서, 해당 값이 countingArr에는 어디에 위치하는지를 보고 이를 넣어준다.
   4. 맨 앞까지 반복한다
(inplace 정렬은 아닌 것을 확인할 수 있다.)